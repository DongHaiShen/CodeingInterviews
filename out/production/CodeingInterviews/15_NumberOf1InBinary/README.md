[TOC]

## 二进制中1的个数

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

### 解法

#### 解法1
循环判断数字n的每一位是否为1，具体方法有两种：
+ 一种是每次将n进行右移，再和1进行与操作，即 $ (n>>1) \& 1$，这种方法的问题在于当n为负数时可能会死循环；
+ 为了避免死循环，**可以考虑移动标记 $flag$**，即 $ n \& ( flag << 1)$

时间复杂度：O(n)

空间复杂度：O(n)

#### 代码
```java
public class NumberOf1InBinary
{
    /**
     * 常规做法，依次判断 n 的每一位是否为 1
     * 不移动数字 n，而改为移动标记flag，防止 n为负时产生死循环
     *
     * @param n 待计算数字
     * @return 1的个数
     */
    public int numberOfOne(int n)
    {
        int count = 0, flag = 1;
        while (flag != 0)
        {
            if ((n & flag) != 0)
            {
                count++;
            }
            flag <<= 1;
        }
        return count;
    }
}
```



#### 解法2 （推荐）
利用一个重要的数学推论：
+ **将 n 与 n-1 做与操作**，即 $n \& (n-1)$，可以将 n 的二进制表示中**最右边的 1 变为 0**；
+ 使用这种做法，n的二进制中有多少个1，只要做多少次操作即可

**注意：把一个整数减去 1 之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的 1 变成 0。很多二进制的问题都可以用这种思路解决。**

时间复杂度：O(n)

空间复杂度：O(1)

#### 代码
```java
public class NumberOf1InBinary
{
    /**
     * 利用公式 n & (n-1)的特性
     * 每次可将n最右边的1变为0
     *
     * @param n 待计算数字
     * @return 1的个数
     */
    public int numberOfOneWithFormula(int n)
    {
        int count = 0;
        while (n != 0)
        {
            n = n & (n - 1);
            count++;
        }
        return count;
    }
}
```



### 测试用例参考
1. 正数（包括边界值 1、0x7FFFFFFF）；
2. 负数（包括边界值 0x80000000、0xFFFFFFFF）；
3. 0。



### 相关题目
1. 用一条语句判断一个整数是不是 2 的整数次方
+ 若一个整数是 2 的整数次方，**则它的二进制中有且只有一位是1**；
+ 根据上述推论，若 $(n\&(n-1))==0​$，则是，否则不是



2. 输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n
+ 第一步先求这两个数的异或，**则两个数在同一位上若不同则会得1**；
+ 根据上述推论**统计异或结果中 1 的个数**






