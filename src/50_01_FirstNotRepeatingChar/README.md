[TOC]

## 第一个只出现一次的字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的**位置**
如果没有则返回 -1（需要区分大小写）.

### 解法
+ 利用空间换时间，构造一个哈希表，第一次遍历记录每个字符出现的次数，然后第二次遍历找出所需字符对应位置；
+ 这里因为字符只有256种可能，因此可以**用数组实现简单哈希表**，减少开销


#### 代码
```java
public class FirstNotRepeatingChar
{
    /**
     * 第一个只出现一次的字符的位置
     *
     * @param str 字符串
     * @return 字符位置，没有返回-1
     */
    public int firstNotRepeatingChar(String str)
    {
        if (str == null || str.length() == 0)
        {
            return -1;
        }

        // 这里因为字符只有256种可能，因此可以用数组实现简单哈希表
        int[] map = new int[256];
        for (int i = 0; i < str.length(); i++)
        {
            map[(int) str.charAt(i)]++;
        }

        for (int i = 0; i < str.length(); i++)
        {
            if (map[(int) str.charAt(i)] == 1)
            {
                return i;
            }
        }
        return -1;
    }
}
```



### 测试用例参考
1. 功能测试（字符串中仅存在只出现一次的字符；字符串中不存在只出现一次的字符；字符串中所有字符都只出现一次）。
2. 特殊输入测试（字符串为null）。



### 相关题目
1. 输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。
+ 用上述哈希表方式存储第二个字符串的所有字符，再遍历第一个字符串进行判断和删除。



2. 删除字符串中所有重复出现的字符。
+ 创建一个**布尔类型**的哈希表，顺序遍历字符串，第一次出现则把哈希表对应位置置为 true，第二次再遇到发现已为 true 就直接删除，总共只需遍历一次。



3. 在英语中，若两个单词中出现的字母相同，且每个字母出现的次数也相同，则称它们互为**变位词**，如 silent 和 listen。判断两个单词是否为变位词。
+ 用一个哈希表记录第一个单词中出现的字母及其次数，然后遍历第二个单词，对每个字符，**在哈希表对应位置上把次数减去1**（因为可能存在多次）。最终若所有字符的次数都减为0，则互为变位词。







